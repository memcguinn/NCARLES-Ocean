module reaction
  use fields, only: t
  use con_data, only: time,dt
  use pars, only: nscl
  implicit none

!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Parameters

  ! LOCATED IN MODULES/PAR.F
  ! flg_reaction : Flag to turn on or off the reaction models

  ! LOCATED IN TRACER/TRACERBC.F90
  ! rmodel       : An array of models to be used in the reactive tracers. Models are
  !                separated out in the react_src function
  ! rdorg        : An array of 0 or 1, 0 = decaying reaction, 1 = growing reaction
  ! rpartner     : An array dictating what tracers are coupled to each other
  ! tau          : The timescale to be used.

  ! flg_debug    : Write a debug file
  integer, parameter :: flg_debug = 0

contains

  ! REACT_SRC: calculate the scalar reaction source term for a given scalar
  !            and point. This is called in rhs_scl for each scalar.
  function react_src(ix,iy,iscl,iz)
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, dimension(NN) :: react_src
    integer, intent(in) :: ix, iy, iscl, iz

    integer :: i
    real*8, dimension(0:NN-1) :: co2, co2tmp
    real*8 :: temper
    real*8 :: h, t_rkc, t_next, t_end, task
    integer :: steps

    !!!!!!!!!!!!!
    !! Zeebe et al. 2001 Carbonate Chemistry
    !!!!!!!!!!!!!

    h      = 1.0e-4
    t_rkc  = time
    t_next = time + h
    t_end  = time + dt
    task   = 1
    steps  = 0

    ! C(1) = Carbon Dioxide, [CO2], t(ix,iy,2,iz)
    ! C(2) = Bicarbonate, [HCO3-], t(ix,iy,3,iz)
    ! C(3) = Carbonate, [CO32-], t(ix,iy,4,iz)
    ! C(4) = Boric Acid, [B(OH)3], t(ix,iy,5,iz)
    ! C(5) = Tetrahydroxyborate, [B(OH)4-], t(ix,iy,6,iz)
    ! C(6) = Hydrogen Ion, [H+], t(ix,iy,7,iz)
    ! C(7) = Hydroxide, [OH-], t(ix,iy,8,iz)
       
    co2(0) = t(ix,iy,2,iz)
    co2(1) = t(ix,iy,3,iz)
    co2(2) = t(ix,iy,4,iz)
    co2(3) = t(ix,iy,5,iz)
    co2(4) = t(ix,iy,6,iz)
    co2(5) = t(ix,iy,7,iz)
    co2(6) = t(ix,iy,8,iz)
    temper = t(ix,iy,1,iz)

    do while (t_rkc < t_end)
       steps = steps + 1
       
       co2tmp = intDriver(t_rkc, t_next, co2, temper)

       do i = 0,NN-1
          co2(i) = co2tmp(i)
       enddo

       t_rkc  = t_next
       t_next = t_next + h
    end do

    do i = 0,NN-1
       react_src(i+1) = co2(i)
    enddo

  end function react_src

  function intDriver(t_rkc, t_end, yGlobal, temper)
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, intent(in) :: t_rkc
    real*8, intent(in) :: t_end, temper
    real*8, intent(in), dimension(0:NN-1) :: yGlobal
    real*8, dimension(0:NN-1) :: intDriver
    real*8, dimension(0:NN-1) :: yLocal, yLocal2
    real*8, dimension(0:4+NN-1) :: workLocal
    integer i

    workLocal(:) = 0.0

    do i = 0,NN-1
       yLocal(i)    = yGlobal(i)
    enddo

    yLocal2 = rkc_driver(t_rkc, t_end, workLocal, yLocal, temper)

    do i = 0,NN-1
       yLocal(i)      = yLocal2(i)
       intDriver(i)   = yLocal2(i)
    enddo

  end function intDriver

  function rkc_driver(t_rkc2, t_end, jwork, yLocal, temper)
    ! Driver function for RKC integrator.
    !
    ! t_tkc    the starting time.
    ! t_end    the desired end time.
    ! task     0 to take a single integration step, 1 to integrate to tEnd.
    ! work     Real work array, size 3.
    ! yLocal   Dependent variable array, integrated values replace initial conditions.
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, intent(in) :: t_rkc2
    real*8, intent(in) :: t_end, temper
    real*8, intent(inout), dimension(0:NN-1) :: yLocal
    real*8, dimension(0:NN-1) :: rkc_driver
    real*8, intent(inout), dimension(0:4+NN-1) :: jwork
    real*8, dimension(0:NN-1) :: y_n, F_n, temp_arr, temp_arr2
    integer nstep, m_max, i, m
    real*8 abs_tol, rel_tol, UROUND, hmax, hmin, err, est
    real*8 fac, temp1, temp2, t_rkc

    t_rkc = t_rkc2
    nstep   = 0
    rel_tol = 1.0e-6
    abs_tol = 1.0e-10
    UROUND  = 2.22e-16
    m_max   = nint(sqrt(rel_tol / (10.0 * UROUND)))
    hmax    = abs(t_end - t_rkc)
    hmin    = 10.0 * UROUND * max(abs(t_rkc), hmax)

    if(m_max < 2)then 
       m_max = 2
    endif

    do i = 0,NN-1
       y_n(i) = yLocal(i)
    enddo
    
    ! calculate F_n for initial y
    F_n = dydt(t_rkc, y_n, temper)

    ! load initial estimate for eigenvector
    if(jwork(2) < UROUND) then
       do i = 0,NN-1
          jwork(4+i) = F_n(i)
       enddo
    endif

    do while (t_rkc < t_end)
       ! use time step stored in work(3)

       ! estimate Jacobian spectral radius
       ! only if 25 steps passed
       ! spec_rad = work(4)
       temp_arr(:)  = 0.0
       temp_arr2(:) = 0.0
       err          = 0.0

       if(mod(nstep,25) == 0)then
          jwork(3) = rkc_spec_rad(t_rkc, hmax, y_n, F_n, jwork(4), temp_arr2, temper)
       endif

       ! first step, estimate step size
       if(jwork(2) < UROUND)then
          jwork(2) = hmax
          if((jwork(3) * jwork(2)) > 1.0)then
             jwork(2) = 1.0/jwork(3)
          endif
          jwork(2) = max(jwork(2), hmin)

          do i = 0,NN-1
             temp_arr(i) = y_n(i) + (jwork(2) * F_n(i))
          enddo
          temp_arr2 = dydt(t_rkc + jwork(2), temp_arr, temper)

          err = 0.0
          do i = 0,NN-1
             est = 0.0
             est = (temp_arr2(i) - F_n(i)) / (abs_tol + rel_tol * abs(y_n(i)))
             err = err + est*est
          enddo
          err = jwork(2) * sqrt(err/real(NN))

          if((0.1 * jwork(2)) < (hmax * sqrt(err)))then
             jwork(2) = max((0.1 * jwork(2)) / sqrt(err), hmin)
          else
             jwork(2) = hmax
          endif
       endif

       ! check if last step
       if((1.1 * jwork(2)) .ge. abs(t_end - t_rkc))then
          jwork(2) = abs(t_end - t_rkc)
       endif

       ! calculate number of steps
       m = 1 + nint(sqrt(1.54 * jwork(2) * jwork(3) + 1.0))

       if(m > m_max)then
          m = m_max
          jwork(2) = real((m*m - 1)) / (1.54*jwork(3))
       endif

       hmin = 10.0 * UROUND * max(abs(t_rkc), abs(t_rkc + jwork(2)))

       ! perform tentative time step
       yLocal = rkc_step(t_rkc, jwork(2), y_n, F_n, m, temper)

       ! calculate F_np1 with tenative y_np1
       temp_arr = dydt(t_rkc + jwork(2), yLocal, temper)

       ! estimate error
       err = 0.0
       do i = 0,NN-1
          est = 0.0
          est = 0.8 * (y_n(i) - yLocal(i)) + 0.4 * jwork(2) * (F_n(i) + temp_arr(i))
          est = est / (abs_tol + rel_tol * max(abs(yLocal(i)), abs(y_n(i))))
          err = err + est*est
       enddo
       err = sqrt(err / real(NN))

       if (err > 1.0) then
          ! error too large, step is rejected

          ! select smaller step size
          jwork(2) = 0.8 * jwork(2) / (err**(1.0/3.0))

          ! reevaluate spectral radius
          jwork(3) = rkc_spec_rad(t_rkc, hmax, y_n, F_n, jwork(4), temp_arr2, temper)
       else
          ! step accepted
          t_rkc = t_rkc + jwork(2)
          nstep = nstep + 1

          fac   = 10.0
          temp1 = 0.0
          temp2 = 0.0
          if(jwork(1) < UROUND)then
             temp2 = err**(1.0/3.0)
             if(0.8 < (fac * temp2))then 
                fac = 0.8 /  temp2
             endif
          else
             temp1 = 0.8 * jwork(2) * (jwork(0)**(1.0/3.0))
             temp2 = jwork(1) * (err**(2.0/3.0))
             if(temp1 < (fac * temp2))then 
                fac = temp1 / temp2
             endif
          endif

          ! set "old" values to those for current time step
          jwork(0) = err
          jwork(1) = jwork(2)

          do i = 0,NN-1
             y_n(i) = yLocal(i)
             F_n(i) = temp_arr(i)
          enddo

          ! store next time step
          jwork(2) = jwork(2) * max(0.1, fac)
          jwork(2) = max(hmin, min(hmax, jwork(2)))

       endif
    enddo

    do i = 0,NN-1
       rkc_driver(i) = yLocal(i)
    enddo

  end function rkc_driver

  real function rkc_spec_rad(t_rkc, hmax, yLocal, F, v, Fv, temper)
    ! Function to estimate spectral radius.
    !
    ! t_rkc    the time.
    ! hmax     Max time step size.
    ! yLocal   Array of dependent variable.
    ! F        Derivative evaluated at current state
    ! v
    ! Fv
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, intent(in) :: t_rkc
    real*8, intent(in) :: hmax, temper
    real*8, intent(inout), dimension(0:NN-1) :: v, Fv, F
    real*8, intent(in), dimension(0:NN-1) :: yLocal
    integer itmax, i, iter, ind
    real*8 UROUND, small, nrm1, nrm2, dynrm, sigma

    UROUND  = 2.22e-16
    itmax   = 50
    small   = 1.0 / hmax
    nrm1    = 0.0
    nrm2    = 0.0
    sigma   = 0.0

    do i = 0,NN-1
       nrm1 = nrm1 + yLocal(i) * yLocal(i)
       nrm2 = nrm2 + v(i) * v(i)
    enddo
    nrm1 = sqrt(nrm1)
    nrm2 = sqrt(nrm2)

    if((nrm1 .ne. 0.0) .and. (nrm2 .ne. 0.0))then
       dynrm = nrm1 * sqrt(UROUND)
       do i = 0,NN-1
          v(i) = yLocal(i) + v(i) * (dynrm / nrm2)
       enddo
    elseif(nrm1 .ne. 0.0)then
       dynrm = nrm1 * sqrt(UROUND)
       do i = 0,NN-1
          v(i) = yLocal(i) * (1.0 + sqrt(UROUND))
       enddo
    elseif(nrm2 .ne. 0.0)then
       dynrm = UROUND
       do i = 0,NN-1
          v(i) = v(i) * (dynrm / nrm2)
       enddo
    else
       dynrm = UROUND
       do i = 0,NN-1
          v(i) = UROUND
       enddo
    endif

    ! now iterate using nonlinear power method
    sigma = 0.0
    do iter = 1,itmax
       Fv = dydt(t_rkc, v, temper)

       nrm1 = 0.0
       do i = 0,NN-1
          nrm1 = nrm1 + ((Fv(i) - F(i)) * (Fv(i) - F(i)))
       enddo
       nrm1  = sqrt(nrm1)
       nrm2  = sigma
       sigma = nrm1 / dynrm
       if((iter .ge. 2) .and. (abs(sigma - nrm2) .le. (max(sigma, small) * 0.01)))then
          do i = 0,NN-1
             v(i) = v(i) - yLocal(i)
          enddo
          rkc_spec_rad = 1.2 * sigma
       endif

       if(nrm1 .ne. 0.0)then
          do i = 0,NN-1
             v(i) = yLocal(i) + ((Fv(i) - F(i)) * (dynrm / nrm1))
          enddo
       else
          ind = int(mod(iter, NN))
          v(ind) = yLocal(ind) - (v(ind) - yLocal(ind))
       endif
    enddo

    rkc_spec_rad = 1.2 * sigma
  
  end function rkc_spec_rad

  function rkc_step(t_rkc, h, y_0, F_0, s, temper)
    ! Function to take a single RKC integration step
    !
    ! t_rkc    the starting time.
    ! h        Time-step size.
    ! y_0      Initial conditions.
    ! F_0      Derivative function at initial conditions.
    ! s        number of steps.
    ! rkc_step Integrated variables
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, intent(in) :: t_rkc
    real*8, intent(in) :: h, temper
    real*8, intent(inout), dimension(0:NN-1) :: y_0, F_0
    integer, intent(in) :: s
    real*8, dimension(0:NN-1) :: rkc_step
    real*8, dimension(0:NN-1) :: y_j
    real*8 w0, temp1, temp2, arg, w1, b_jm1, b_jm2, mu_t
    real*8 c_jm2, c_jm1, zjm1, zjm2, dzjm1, dzjm2, d2zjm1, d2zjm2
    real*8 zj, dzj, d2zj, b_j, gamma_t, nu, mu, c_j
    real*8, dimension(0:NN-1) :: y_jm1, y_jm2
    integer i, j

    w0    = 1.0 + 2.0 / (13.0 * real(s * s))
    temp1 = (w0 * w0) - 1.0
    temp2 = sqrt(temp1)
    arg   = real(s) * log(w0 + temp2)
    w1    = sinh(arg) * temp1 / (cosh(arg) * real(s) * temp2 - w0 * sinh(arg))

    b_jm1 = 1.0 / (4.0 * (w0 * w0))
    b_jm2 = b_jm1

    ! calculate y_1
    mu_t = w1 * b_jm1
    do i = 0,NN-1
       y_jm2(i) = y_0(i)
       y_jm1(i) = y_0(i) + (mu_t * h * F_0(i))
    enddo

    c_jm2 = 0.0
    c_jm1 = mu_t
    zjm1 = w0
    zjm2 = 1.0
    dzjm1 = 1.0
    dzjm2 = 0.0
    d2zjm1 = 0.0
    d2zjm2 = 0.0

    do j = 2,s

       zj = 2.0 * w0 * zjm1 - zjm2
       dzj = 2.0 * w0 * dzjm1 - dzjm2 + 2.0 * zjm1
       d2zj = 2.0 * w0 * d2zjm1 - d2zjm2 + 4.0 * dzjm1
       b_j = d2zj / (dzj * dzj)
       gamma_t = 1.0 - (zjm1 * b_jm1)

       nu = -b_j / b_jm2
       mu = 2.0 * b_j * w0 / b_jm1
       mu_t = mu * w1 / w0

       ! calculate derivative, use y array for temporary storage
       y_j = dydt(t_rkc + (h * c_jm1), y_jm1, temper)

       do i = 0,NN-1
          y_j(i) = (1.0 - mu - nu) * y_0(i) + (mu * y_jm1(i)) + (nu * y_jm2(i)) &
               + h * mu_t * (y_j(i) - (gamma_t * F_0(i)))
       enddo
       c_j = (mu * c_jm1) + (nu * c_jm2) + mu_t * (1.0 - gamma_t)

       if(j < s)then
          do i = 0,NN-1
             y_jm2(i) = y_jm1(i)
             y_jm1(i) = y_j(i)
          enddo
       endif

       c_jm2  = c_jm1
       c_jm1  = c_j
       b_jm2  = b_jm1
       b_jm1  = b_j
       zjm2   = zjm1
       zjm1   = zj
       dzjm2  = dzjm1
       dzjm1  = dzj
       d2zjm2 = d2zjm1
       d2zjm1 = d2zj
    enddo

    do i = 0,NN-1
       rkc_step(i) = y_j(i)
    enddo

  end function rkc_step
    
  function dydt(t_rkc, y, temper)
    implicit none
    integer, parameter :: NN = nscl-1
    real*8, intent(in),  dimension(0:NN-1) :: y
    real*8, dimension(0:NN-1) :: dydt
    real*8, dimension(NN) :: c
    real*8, intent(in) :: t_rkc, temper
    real*8 K1s, K2s, Kw, Kb, Rgas, salt
    integer i
    real*8 a1, a2, a3, a4, a5, a6, a7
    real*8 b1, b2, b3, b4, b5, b6, b7

    salt   = 35.0
    do i = 0,NN-1
       c(i+1) = y(i)
    enddo
    
    K1s = exp(-2307.1266/temper + 2.83655 - 1.5529413*log(temper) + &
         (-4.0484/temper - 0.20760841)*(salt**0.5) + 0.08468345*salt - &
         0.00654208*(salt**1.5) + log(1.0-0.001005*salt))*(1.0e6)
    K2s = exp(-3351.6106/temper - 9.226508 - 0.2005743*log(temper) + &
         (-23.9722/temper - 0.106901773)*(salt**0.5) + 0.1130822*salt - &
         0.00846934*(salt**1.5) + log(1.0-0.001005*salt))*(1.0e6)
    Kw = exp(148.96502 - 13847.26/temper - 23.65218*log(temper) + &
         (118.67/temper - 5.977 + 1.0495*log(temper))*(salt**0.5) - &
         0.01615*salt)*(1.0e6) !(DoE, 1994)
    Kb = exp((-8966.9 - 2890.53*(salt**0.5) - 77.942*salt + &
         1.728*(salt**1.5) - 0.0996*(salt**2))/temper &
         + 148.0248 + 137.1942*(salt**0.5) + 1.62142*salt - &
         (24.4344 + 25.085*(salt**0.5) + 0.2474*salt)*log(temper) + &
         0.053105*(salt**0.5)*temper)*(1.0e6) !(Dickson, 1990)
    Rgas = 0.0083143
    
    a1 = exp(1246.98-6.19*(10.0**4)/temper - 183.0*log(temper))
    a2 = (4.7e7)*exp(-23.3/(Rgas*temper))/(1.0e6)
    a3 = (5.0e10)/(1.0e6)
    a4 = (6.0e9)/(1.0e6)
    a5 = (1.4e-3)*(1.0e6)
    a6 = (4.58e10)*exp(-(20.8/(Rgas*temper)))/(1.0e6)
    a7 = (3.05e10)*exp(-(20.8/(Rgas*temper)))/(1.0e6)
    b1 = a1/K1s
    b2 = (Kw*a2/K1s)*(1.0e6)
    b3 = a3*K2s
    b4 = (a4*Kw/K2s)*(1.0e6)
    b5 = (a5/Kw)/(1.0e6)
    b6 = (a6*Kw/Kb)*(1.0e6)
    b7 = a7*K2s/Kb

!    c(6) = (a1*c(1) + b3*c(2) + a5)/(b1*c(2) + a3*c(3) + b5*c(7))
       
    dydt(0) = b1*c(2)*c(6)+b2*c(2)-a1*c(1)-a2*c(1)*c(7)

    dydt(1) = a1*c(1)+a2*c(1)*c(7)-b1*c(2)*c(6)-b2*c(2) &
         +a3*c(3)*c(6)-b3*c(2)-a4*c(2)*c(7)+b4*c(3) &
         +a7*c(3)*c(4)-b7*c(5)*c(2)

    dydt(2) = -a3*c(3)*c(6)+ b3*c(2)+a4*c(2)*c(7)-b4*c(3) &
         -a7*c(3)*c(4)+b7*c(5)*c(2) 

    dydt(3) = -a6*c(4)*c(7)+ b6*c(5)-a7*c(3)*c(4)+b7*c(5)*c(2)

    dydt(4) = a6*c(4)*c(7)- b6*c(5)+a7*c(3)*c(4)-b7*c(5)*c(2)

    dydt(5) = a1*c(1)-b1*c(2)*c(6)-a3*c(3)*c(6)+b3*c(2)+a5-b5*c(6)*c(7)

    dydt(6) = b2*c(2)-a2*c(1)*c(7)-a4*c(2)*c(7)+b4*c(3)+a5 &
         -b5*c(6)*c(7)-a6*c(4)*c(7)+b6*c(5)

  end function dydt
end module reaction

